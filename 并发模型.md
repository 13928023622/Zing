# 两种高效的事件处理模式

同步I/O模型通常用于实现Reactor模式，异步模型常用于实现Proactor模式

## Reactor模式

Reacotr模式本质上来讲，他要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），除此之外，主线城不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

使用同步I/O模型（epoll_wait为例）实现的Reactor模式工作流程：

* 主线程往epoll内核事件表中组册socket上的读就绪事件。
* 主线程调用epoll_wait等待socket上有数据可读
* 当socket上有数据可读时，epoll_wait通知主线程。主线城则将socket可读事件放入请求队列。
* 睡眠在请求队列上的某个线程被唤醒，他从socket读取数据，并处理客户请求，然后往epoll内核事件中组册该socket上的写就绪事件。
* 主线程调用epoll_wait等待socket可写.
* 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列。
* 睡眠在请求队列上的某个工作线程被唤醒，往socket上写入服务器处理客户请求的结果。

## Proactor模式

与Reactor模式不同，Proactor模式将所有的I/O操作都交给主线程和内核处理，工作线程仅仅负责业务逻辑。

使用异步I/O模型（以aio_read 和 ari_write为例）实现Proactor工作流程如下：

* 主线程调用他ari_read函数向内核注册socket上的读就绪完成事件，并告诉内核缓冲区的位置，以及读操作完成时如何同志应用程序。
* 主线程继续处理其他逻辑
* 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。
* 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户的请求。工作线程处理完客户请求后，调用ari_write函数向内核注册socket上的写就绪事件，并告诉内核用户缓冲区的位置，以及写操作完成时如何通知应用程序。
* 出线程继续处理其他逻辑
* 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据几经发送完毕
* 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket

从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序（Zing中为worker线程）自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，操作系统会读取缓存区或者写入缓存区到真正的IO设备。

# 并发模型

### 半同步/半异步模式

​	此 “同步”，”异步“ 不同于I/O的同步异步概念（内核向应用程序通知的是何种I/O事件是就绪事件还是完成事件，以及有谁来完成I/O读写是应用程序还是内核）。在并发模式中，“同步”指的是程序完全顺序执行，“异步”指的是程序的执行需要由系统事件来驱动。

​	Linux内核2.6之后开始支持epoll，也是本服务器的核心。epoll模型中内核相当于监控代理，监控粒度为每一个事件，我们把每个完整的处理过程拆分成多个独立事件在epoll中组册，之后监控是否有事件发生的任务交给内核来做，一旦检测到了事件就分发到相应处理模块。就HTTP服务器而言，可以分为一下几步

* 首先需要注册到“监听事件”，之后不需要一直等待下去，直接返回。

* 一旦内核监听到请求就会自动通知可以去建立连接并创建连接描述符，该连接描述符被注册到读事件，之后立即返回。

* 用户发送的数据到达服务器，内核感知到读事件，建立任务并放入线程池中。之后唤醒等待任务的worker线程来执行响应操作。

  ​	Zing用使用non-blocking I/O， 读事件并不会阻塞等待用户数据，一直等到内核通知该事件到来才去获得请求，当请求到达后，处理请求的操作被放入到线程池中，等待多个线程并发响应处理，即使某一线程读取本地文件时被阻塞也会有其他线程可以被调度执行。

  ​	之所以选择epoll模型是因为事件驱动适合I/O密集型操作，而HTTP服务器最核心的任务就是响应请求的数据，设计大量I/IO请求，另外当并发量上来之后，传统的多线程，多进程虽然并发量很大，但大多处于阻塞状态，即使多为就绪，系统调度开销也非常大，因此使用事件驱动模型无疑更合适。

  ​	综上，Zing核心框架就是同步事件循环+非阻塞I/O+线程池，是否是阻塞I/O指的是read或者write等系统调用在数据为准备好之前是一直阻塞还是立即返回并设置errno 为 EAGAIN（巡回检测），此处异步指的是并发模型中的异步即程序执行需要系用事件来驱动；



​	



