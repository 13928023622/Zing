# Zing整体架构

## 初始化

* 读取配置

* 绑定地址与监听（LISTENQ = 1024）

* 创建epoll并添加监听符。

* 初始化线程池

  * 初始化线程池各参数
  * 创建线程
  * 调用threadpool_workerh函数（每个worker线程循环执行以下几步）：
    * 每个worker线程进入线程池都先对线程池互斥锁
    * 如果有任务（通过threadpool_add添加），则取出队列中的第一个节点。
    * 堆线程池开锁，之后其他线程可以访问线程池
    * 执行每个任务对应的操作并删除该任务。

  注：这里要先开锁后执行对应的任务，因为再此情况下已经完成了对该worker线程任务的分配，不可能将其他任务在分配给此线程，其他线程的并发操作也不会对其有任何影响。另外如果将开锁过程置于任务执行之后，则线程池会被加锁至前进一个任务执行结束，整个线程池处于被锁定状态。任务会退化成为顺序执行，所以这里先开锁很重要。

* 初始化定时器：

  * 初始化定时器优先队列。
  * 更新当前时间。

## 任务处理

* 请求连接（事件：有连接请求）：
* 接受连接并返回连接描述符。
* 向epoll中组册新的描述符。
* 新增时间戳信息， 新的时间戳被加入到优先队列：
  * 最早超时时间节点在队列头。
* 响应任务（事件：请求到服务器）：
  * 将新建的任务加入到线程池中，处理函数为do_request,参数为请求结构（z_request_t）。
    * 完成z_task_t节点初始化，任务数量queue_size加1.
    * 将新任务挂在线程池tast队列。
    * 调用pthread_cond_signal激活一个等待该条件的线程（只激活一个，避免惊群效应）。在初始化时，线程池中多个线程因为任务队列为空，所以调用pthread_cond_wait被休眠。一旦有新的任务被加入线程池，条件变量（任务队列非空）即可被满足，此时会唤醒工作线程来处理任务。

## 具体处理用户请求过程

某一具体任务被添加进task队列中就会激活一个worker线程去处理请求，入口函数为do_request。

* 删除该请求定时器：
  * 以为该任务已经响应，且为超时，不再需要定时器去处理该连接的超时情况，接下来在定时器队列中删除该请求的定时器。这就是为什么z_request_t 和z_timer_t 结构中互相指向彼此指针的原因。
* 读取用户请求：
  * 数据读取发生错误（errno非EAGAIN）则关闭连接。
  * 若errno为EAGAIN：
    * 跳出循环（外层循环主要是i为了触发EAGAIN条件）。
    * 将该请求重设定时器并于epoll中重新组册。
    * 结束do_request函数，释放worker线程控制权（tcp未断开）。
* 解析请求并填充z_request_t各变量。
* 获取用户请求文件名，判断默认目录下该文件权限等基本信息：
  * 如果有错误信息返回错误响应体。
* 返回响应体：
* 若为长连接，则关闭TCP连接并重新回到循环中。若为短连接则断开连接。